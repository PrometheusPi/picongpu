/* Copyright 2013-2021 Axel Huebl, Rene Widera, Felix Schmitt,
 *                     Richard Pausch, Marco Garten
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "picongpu/particles/densityProfiles/profiles.def"
#include "picongpu/particles/traits/GetDensityRatio.hpp"
/* preprocessor struct generator */
#include <pmacc/preprocessor/struct.hpp>

namespace picongpu
{
    namespace SI
    {
        /** Base density in particles per m^3 in the density profiles.
         *
         * This is often taken as reference maximum density in normalized profiles.
         * Individual particle species can define a `densityRatio` flag relative
         * to this value.
         *
         * unit: ELEMENTS/m^3
         */
        constexpr float_64 BASE_DENSITY_SI = 1.e25;
    } // namespace SI

    namespace densityProfiles
    {
        namespace pypicongpu {
            {{#species_initmanager.operations.simple_density}}
                /**
                * generate the initial macroparticle position for species "{{{placed_species_initial.name}}}" ({{{placed_species_initial.typename}}})
                *
                * result is already multiplied with densityRatio of {{{placed_species_initial.typename}}},
                * i.e. CreateDensity must ignore the density ratio
                */
                struct init_{{{placed_species_initial.typename}}}_with_ratio_functor
                {
                    HDINLINE float_X operator()(const floatD_64& position_SI, const float3_64& cellSize_SI)
                    {
                        // TODO: respect bounding box

                        {{! note: density_without_ratio is defined inside of each block
                            rationale: sometimes constexpr is valid, sometimes not }}

                        {{#profile.type.uniform}}
                            // note: right hand side is double
                            constexpr float_X density_without_ratio = {{{profile.data.density_si}}} / SI::BASE_DENSITY_SI;
                        {{/profile.type.uniform}}

                        {{#placed_species_initial.constants.density_ratio}}
                            {{! directly multiply with ratio }}
                            return {{{placed_species_initial.constants.density_ratio.ratio}}} * density_without_ratio;
                        {{/placed_species_initial.constants.density_ratio}}
                        {{^placed_species_initial.constants.density_ratio}}
                            {{! no density ratio }}
                            return density_without_ratio;
                        {{/placed_species_initial.constants.density_ratio}}
                    }
                };

            using init_{{{placed_species_initial.typename}}}_with_ratio = FreeFormulaImpl<init_{{{placed_species_initial.typename}}}_with_ratio_functor>;
            {{/species_initmanager.operations.simple_density}}

            /**
             * generate a globally uniform density
             *
             * @tparam density_float_si struct, which operator() returns a constexpr float
             */
            template <typename density_float_si>
            struct Uniform
            {
                HDINLINE float_X operator()(const floatD_64& position_SI, const float3_64& cellSize_SI)
                {
                    return density_float_si()() / SI::BASE_DENSITY_SI;
                }
            };

            /**
             * Wraps a density functor **implementation** and multiplies it with the given factor.
             *
             * Main usecase is to emulate the densityWeighting of the species flags during initialization.
             *
             * Use:
             * FactorImpl<densityProfiles::FreeFormulaImpl<FUNCTOR>, FACTORSTRUCT>
             *
             * @tparam T_Impl existing density functor
             * @tparam T_Factor struct for which op() returns a factor
             * @see pypicongpu::util::TplFloatAny
             */
            template<typename T_Impl, typename T_Factor>
            struct FactorImpl : public T_Impl
            {
                template<typename T_SpeciesType>
                struct apply
                {
                    using type = FactorImpl<T_Impl, T_Factor>;
                };

                // Constructor -> invoke T_Impl constructor
                HDINLINE FactorImpl(uint32_t currentStep) : T_Impl(currentStep)
                {
                }

                /** Calculate the normalized density
                 * Delegates actual density computation to T_Impl.
                 * 
                 * @param totalCellOffset total offset including all slides [in cells]
                 */
                HDINLINE picongpu::float_X operator()(const DataSpace<simDim>& totalCellOffset)
                {
                    // note: T_Factor()() should be a constexpr, hence the instanciation & op() call (which both are expensive) should (tm) be optimized away automatically during compilation
                    return T_Factor()() * T_Impl::operator()(totalCellOffset);
                }
            };

            /**
             * Wraps a density **functor** and only applies it in the given bounds.
             *
             * Main usecase is to apply a density within local bounds.
             * Locations out of bound are set to 0.
             *
             * Use:
             * FreeFormulaImpl<BoundaryFunctor<uniform<num>, x, y, z, ...>>
             *
             * @tparam T_Impl existing density **functor**
             * @tparam T_min_x_si lower bound (inclusive) for application
             * @tparam T_min_y_si lower bound (inclusive) for application
             * @tparam T_min_z_si lower bound (inclusive) for application
             * @tparam T_max_x_si upper bound (inclusive) for application
             * @tparam T_max_y_si upper bound (inclusive) for application
             * @tparam T_max_z_si upper bound (inclusive) for application
             * @see pypicongpu::util::TplFloatAny
             */
            template<typename T_Impl,
                     typename T_min_x_si, typename T_min_y_si, typename T_min_z_si,
                     typename T_max_x_si, typename T_max_y_si, typename T_max_z_si>
            struct BoundaryFunctor : public T_Impl
            {
                // check boundaries
                static_assert(T_min_x_si()() < T_max_x_si()(), "x axis: min must be less than max");
                static_assert(T_min_y_si()() < T_max_y_si()(), "y axis: min must be less than max");
                static_assert(T_min_z_si()() < T_max_z_si()(), "z axis: min must be less than max");

                // Constructor -> invoke T_Impl constructor
                HDINLINE BoundaryFunctor() : T_Impl()
                {
                }
            
                /** Calculate the density
                 * Delegates actual density computation to T_Impl.
                 * 
                 * @param position_SI total offset including all slides [meter]
                 * @param cellSize_SI cell sizes [meter]
                 * @return density derived from T_Impl or 0
                 */
                HDINLINE picongpu::float_X operator()(const floatD_64& position_SI, const float3_64& cellSize_SI)
                {
                    // currently, the cell size is not considered
                    const float_64 x = position_SI.x();
                    const float_64 y = position_SI.y();
                    const float_64 z = position_SI.z();

                    if (x < T_min_x_si()() || x > T_max_x_si()()) {
                        return 0;
                    }
                    if (y < T_min_y_si()() || y > T_max_y_si()()) {
                        return 0;
                    }
                    if (z < T_min_z_si()() || z > T_max_z_si()()) {
                        return 0;
                    }

                    return T_Impl::operator()(position_SI, cellSize_SI);
                }
            };
        } // namespace pypicongpu
    } // namespace densityProfiles
} // namespace picongpu
